<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>How It Works - Audio RNG Password Generator</title>
  <link rel="stylesheet" href="how-it-works.css">
</head>
<body>
  <!-- Header -->
  <header class="header">
    <h1>üî¨ How It Works</h1>
    <p>Understanding the Audio RNG Password Generator</p>
    <a href="index.html" class="back-button">‚Üê Back to App</a>
  </header>

  <!-- Main Content -->
  <div class="container">
    <!-- Overview -->
    <section class="section">
      <h2>üéØ Overview</h2>
      <p>The Audio RNG Password Generator uses your microphone to create truly random numbers through a sophisticated process that combines:</p>
      <ul>
        <li><strong>Audio Noise Collection</strong> - Captures ambient microphone noise</li>
        <li><strong>Von Neumann Correction</strong> - Eliminates bias from the raw audio data</li>
        <li><strong>SHA-256 Hashing</strong> - Adds cryptographic security</li>
        <li><strong>Password Generation</strong> - Creates secure passwords from the random data</li>
      </ul>
      
      <div class="info-box">
        <strong>Why Audio Noise?</strong> Audio noise from your microphone contains true randomness that can't be predicted or reproduced, making it ideal for cryptographic applications.
      </div>
    </section>

    <!-- Process Flow -->
    <section class="section">
      <h2>üîÑ Process Flow</h2>
      <div class="process-flow">
        <div class="process-step">
          <h4>1. Audio Capture</h4>
          <p>Microphone captures ambient noise and converts it to digital audio samples</p>
        </div>
        <div class="process-step">
          <h4>2. Bit Extraction</h4>
          <p>Each audio sample is converted to a single bit (0 or 1) using the least significant bit</p>
        </div>
        <div class="process-step">
          <h4>3. Von Neumann Correction</h4>
          <p>Pairs of bits are analyzed to eliminate bias - only 01 and 10 pairs are kept</p>
        </div>
        <div class="process-step">
          <h4>4. Byte Assembly</h4>
          <p>8 corrected bits are combined to form a single byte (0-255)</p>
        </div>
        <div class="process-step">
          <h4>5. Data Collection</h4>
          <p>1000 bytes are collected before processing</p>
        </div>
        <div class="process-step">
          <h4>6. SHA-256 Hashing</h4>
          <p>The collected data is hashed using SHA-256 for additional security</p>
        </div>
        <div class="process-step">
          <h4>7. Password Generation</h4>
          <p>Random bytes are used to select characters for password generation</p>
        </div>
      </div>
    </section>

    <!-- Technical Details -->
    <section class="section">
      <h2>‚öôÔ∏è Technical Details</h2>
      
      <h3>Audio Processing</h3>
      <p>The app uses the Web Audio API to capture real-time audio from your microphone:</p>
      <div class="code-block">
        <code>
// Audio context setup
const audioCtx = new AudioContext();
const analyser = audioCtx.createAnalyser();
analyser.fftSize = 1024;

// Capture audio data
const data = new Uint8Array(analyser.fftSize);
analyser.getByteTimeDomainData(data);
        </code>
      </div>

      <h3>Von Neumann Correction</h3>
      <p>Raw audio data often contains bias (more 1s than 0s or vice versa). Von Neumann correction eliminates this bias:</p>
      
      <div class="diagram">
        <svg width="400" height="200" viewBox="0 0 400 200">
          <!-- Raw bits -->
          <text x="50" y="30" fill="#ff6b6b" font-size="14" font-weight="bold">Raw Audio Bits:</text>
          <text x="50" y="50" fill="#e0e0e0" font-family="monospace" font-size="12">1 0 1 1 0 0 1 1 0 1 0 0 1 1 0 1</text>
          
          <!-- Pairs -->
          <text x="50" y="80" fill="#4ecdc4" font-size="14" font-weight="bold">Bit Pairs:</text>
          <text x="50" y="100" fill="#e0e0e0" font-family="monospace" font-size="12">10 11 00 11 01 00 11 01</text>
          
          <!-- Filtered -->
          <text x="50" y="130" fill="#45b7d1" font-size="14" font-weight="bold">Von Neumann Filtered:</text>
          <text x="50" y="150" fill="#e0e0e0" font-family="monospace" font-size="12">0 1 0 1</text>
          
          <!-- Arrows -->
          <path d="M 200 60 L 250 60" stroke="#4caf50" stroke-width="2" marker-end="url(#arrowhead)"/>
          <path d="M 200 110 L 250 110" stroke="#4caf50" stroke-width="2" marker-end="url(#arrowhead)"/>
          
          <!-- Legend -->
          <text x="280" y="50" fill="#ff6b6b" font-size="10">Raw (biased)</text>
          <text x="280" y="70" fill="#4ecdc4" font-size="10">Paired</text>
          <text x="280" y="90" fill="#45b7d1" font-size="10">Filtered (unbiased)</text>
          
          <defs>
            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
              <polygon points="0 0, 10 3.5, 0 7" fill="#4caf50"/>
            </marker>
          </defs>
        </svg>
      </div>

      <div class="code-block">
        <code>
// Von Neumann correction algorithm
if (b1 === 0 && b2 === 1) finalBitBuffer.push(0);  // Keep 01 ‚Üí 0
else if (b1 === 1 && b2 === 0) finalBitBuffer.push(1);  // Keep 10 ‚Üí 1
// Discard 00 and 11 pairs (biased)
        </code>
      </div>

      <h3>SHA-256 Hashing</h3>
      <p>After collecting 1000 bytes, the data is hashed using SHA-256 to ensure cryptographic security:</p>
      <div class="code-block">
        <code>
// SHA-256 hashing
const asciiString = String.fromCharCode(...collectedNumbers);
const digest = await crypto.subtle.digest("SHA-256", 
  new TextEncoder().encode(asciiString));
        </code>
      </div>

      <div class="success-box">
        <strong>Security Benefit:</strong> Even if an attacker could somehow predict the audio noise, the SHA-256 hash makes it computationally infeasible to reverse-engineer the original data.
      </div>
    </section>

    <!-- Security Analysis -->
    <section class="section">
      <h2>üîí Security Analysis</h2>
      
      <h3>Entropy Sources</h3>
      <table>
        <thead>
          <tr>
            <th>Source</th>
            <th>Entropy Quality</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Microphone Noise</td>
            <td>High</td>
            <td>Ambient environmental noise, electronic noise, thermal noise</td>
          </tr>
          <tr>
            <td>Von Neumann Correction</td>
            <td>Perfect</td>
            <td>Eliminates all bias, ensuring 50/50 distribution</td>
          </tr>
          <tr>
            <td>SHA-256 Hashing</td>
            <td>Cryptographic</td>
            <td>Provides additional security layer and uniform distribution</td>
          </tr>
        </tbody>
      </table>

      <h3>Attack Resistance</h3>
      <ul>
        <li><strong>Predictability:</strong> Audio noise is inherently unpredictable</li>
        <li><strong>Bias Elimination:</strong> Von Neumann correction removes statistical bias</li>
        <li><strong>Cryptographic Security:</strong> SHA-256 provides one-way hashing</li>
        <li><strong>Local Processing:</strong> All data stays on your device</li>
      </ul>

      <div class="warning-box">
        <strong>Important:</strong> This method is suitable for password generation and non-critical applications. For high-security applications, consider using hardware random number generators or certified cryptographic libraries.
      </div>
    </section>

    <!-- Privacy -->
    <section class="section">
      <h2>üõ°Ô∏è Privacy & Data Handling</h2>
      
      <h3>What We Collect</h3>
      <ul>
        <li><strong>Audio Data:</strong> Processed locally, never transmitted</li>
        <li><strong>Random Numbers:</strong> Generated and used locally only</li>
        <li><strong>Passwords:</strong> Generated and displayed locally only</li>
      </ul>

      <h3>What We Don't Collect</h3>
      <ul>
        <li>No audio data is sent to external servers</li>
        <li>No random numbers are transmitted</li>
        <li>No passwords are stored or transmitted</li>
        <li>No personal information is collected</li>
      </ul>

      <div class="info-box">
        <strong>100% Local Processing:</strong> All audio processing, random number generation, and password creation happens entirely on your device. No data leaves your computer.
      </div>
    </section>

    <!-- Performance -->
    <section class="section">
      <h2>‚ö° Performance Characteristics</h2>
      
      <h3>Generation Speed</h3>
      <ul>
        <li><strong>Raw Bits:</strong> ~1000 bits per second (depends on audio level)</li>
        <li><strong>After Von Neumann:</strong> ~250 bits per second (75% reduction due to filtering)</li>
        <li><strong>Final Output:</strong> ~32 bytes per second (after SHA-256 processing)</li>
      </ul>

      <h3>Quality Metrics</h3>
      <ul>
        <li><strong>Bias:</strong> Eliminated by Von Neumann correction</li>
        <li><strong>Distribution:</strong> Uniform across all byte values (0-255)</li>
        <li><strong>Correlation:</strong> No correlation between consecutive outputs</li>
        <li><strong>Periodicity:</strong> No detectable patterns or cycles</li>
      </ul>

      <h3>Optimization Tips</h3>
      <ul>
        <li>Ensure good microphone input levels (30-70% on the level meter)</li>
        <li>Use in a quiet environment for consistent noise</li>
        <li>Allow the system to collect data for better entropy</li>
        <li>Generate longer passwords for better security</li>
      </ul>
    </section>

    <!-- Mathematical Foundation -->
    <section class="section">
      <h2>üìê Mathematical Foundation</h2>
      
      <h3>Von Neumann Correction Theory</h3>
      <p>If raw bits have bias <em>p</em> (probability of 1), then:</p>
      <ul>
        <li>P(01) = p(1-p)</li>
        <li>P(10) = (1-p)p = p(1-p)</li>
        <li>P(00) = (1-p)¬≤</li>
        <li>P(11) = p¬≤</li>
      </ul>
      
      <p>Since P(01) = P(10), the filtered output has perfect 50/50 distribution regardless of input bias.</p>

      <h3>Entropy Calculation</h3>
      <p>For <em>n</em> bits after Von Neumann correction:</p>
      <ul>
        <li>Entropy = n bits (maximum possible)</li>
        <li>Efficiency = 25% (due to discarding 00 and 11 pairs)</li>
        <li>Quality = Perfect (no bias, uniform distribution)</li>
      </ul>

      <div class="code-block">
        <code>
// Entropy calculation example
const rawBits = 1000;           // Input bits
const bias = 0.6;               // 60% ones, 40% zeros
const keptPairs = rawBits * bias * (1 - bias) * 2;  // ~480 bits
const entropy = keptPairs;      // 480 bits of perfect entropy
        </code>
      </div>
    </section>

    <!-- Conclusion -->
    <section class="section">
      <h2>üéØ Conclusion</h2>
      <p>The Audio RNG Password Generator combines multiple layers of security and randomness to create cryptographically secure passwords:</p>
      
      <ol>
        <li><strong>True Randomness:</strong> Audio noise provides unpredictable entropy</li>
        <li><strong>Bias Elimination:</strong> Von Neumann correction ensures perfect distribution</li>
        <li><strong>Cryptographic Security:</strong> SHA-256 hashing adds additional protection</li>
        <li><strong>Privacy Protection:</strong> All processing happens locally on your device</li>
      </ol>

      <div class="success-box">
        <strong>Result:</strong> You get truly random, secure passwords generated entirely on your device with no external dependencies or privacy concerns.
      </div>

      <div style="text-align: center; margin-top: 2rem;">
        <a href="index.html" class="back-button">üöÄ Try the App</a>
      </div>
    </section>
  </div>
</body>
</html>
