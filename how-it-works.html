<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>How It Works - Audio RNG Password Generator</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: linear-gradient(135deg, #0c0c0c 0%, #1a1a1a 100%);
      color: #e0e0e0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      line-height: 1.6;
      min-height: 100vh;
    }

    /* Header */
    .header {
      background: linear-gradient(90deg, #1e3c72 0%, #2a5298 100%);
      padding: 2rem;
      text-align: center;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    }

    .header h1 {
      font-size: 2.5rem;
      color: white;
      margin-bottom: 0.5rem;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .header p {
      font-size: 1.2rem;
      opacity: 0.9;
    }

    .back-button {
      display: inline-block;
      margin-top: 1rem;
      padding: 12px 24px;
      background: linear-gradient(45deg, #4caf50, #45a049);
      color: white;
      text-decoration: none;
      border-radius: 8px;
      font-weight: 600;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
    }

    .back-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
    }

    /* Main Content */
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 2rem;
    }

    .section {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      padding: 2rem;
      margin-bottom: 2rem;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .section h2 {
      color: #4caf50;
      font-size: 2rem;
      margin-bottom: 1.5rem;
      border-bottom: 3px solid #4caf50;
      padding-bottom: 0.5rem;
    }

    .section h3 {
      color: #66bb6a;
      font-size: 1.5rem;
      margin: 2rem 0 1rem 0;
    }

    .section h4 {
      color: #81c784;
      font-size: 1.2rem;
      margin: 1.5rem 0 0.5rem 0;
    }

    /* Process Flow */
    .process-flow {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 2rem;
      margin: 2rem 0;
    }

    .process-step {
      background: rgba(76, 175, 80, 0.1);
      border: 2px solid #4caf50;
      border-radius: 12px;
      padding: 1.5rem;
      text-align: center;
      position: relative;
    }

    .process-step::before {
      content: counter(step-counter);
      counter-increment: step-counter;
      position: absolute;
      top: -15px;
      left: 50%;
      transform: translateX(-50%);
      background: #4caf50;
      color: white;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 1.2rem;
    }

    .process-flow {
      counter-reset: step-counter;
    }

    /* Code Blocks */
    .code-block {
      background: #1a1a1a;
      border: 2px solid #333;
      border-radius: 8px;
      padding: 1.5rem;
      margin: 1rem 0;
      overflow-x: auto;
      font-family: 'Courier New', monospace;
      font-size: 0.9rem;
    }

    .code-block code {
      color: #4caf50;
    }

    /* Diagrams */
    .diagram {
      background: #1a1a1a;
      border: 2px solid #333;
      border-radius: 8px;
      padding: 2rem;
      margin: 2rem 0;
      text-align: center;
    }

    .diagram svg {
      max-width: 100%;
      height: auto;
    }

    /* Info Boxes */
    .info-box {
      background: rgba(33, 150, 243, 0.1);
      border-left: 4px solid #2196f3;
      padding: 1rem 1.5rem;
      margin: 1rem 0;
      border-radius: 0 8px 8px 0;
    }

    .warning-box {
      background: rgba(255, 193, 7, 0.1);
      border-left: 4px solid #ffc107;
      padding: 1rem 1.5rem;
      margin: 1rem 0;
      border-radius: 0 8px 8px 0;
    }

    .success-box {
      background: rgba(76, 175, 80, 0.1);
      border-left: 4px solid #4caf50;
      padding: 1rem 1.5rem;
      margin: 1rem 0;
      border-radius: 0 8px 8px 0;
    }

    /* Lists */
    ul, ol {
      margin: 1rem 0;
      padding-left: 2rem;
    }

    li {
      margin: 0.5rem 0;
    }

    /* Tables */
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 1rem 0;
      background: #1a1a1a;
      border-radius: 8px;
      overflow: hidden;
    }

    th, td {
      padding: 1rem;
      text-align: left;
      border-bottom: 1px solid #333;
    }

    th {
      background: #4caf50;
      color: white;
      font-weight: 600;
    }

    /* Responsive */
    @media (max-width: 768px) {
      .header h1 {
        font-size: 2rem;
      }
      
      .container {
        padding: 1rem;
      }
      
      .section {
        padding: 1.5rem;
      }
      
      .process-flow {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <!-- Header -->
  <header class="header">
    <h1>üî¨ How It Works</h1>
    <p>Understanding the Audio RNG Password Generator</p>
    <a href="index.html" class="back-button">‚Üê Back to App</a>
  </header>

  <!-- Main Content -->
  <div class="container">
    <!-- Overview -->
    <section class="section">
      <h2>üéØ Overview</h2>
      <p>The Audio RNG Password Generator uses your microphone to create truly random numbers through a sophisticated process that combines:</p>
      <ul>
        <li><strong>Audio Noise Collection</strong> - Captures ambient microphone noise</li>
        <li><strong>Von Neumann Correction</strong> - Eliminates bias from the raw audio data</li>
        <li><strong>SHA-256 Hashing</strong> - Adds cryptographic security</li>
        <li><strong>Password Generation</strong> - Creates secure passwords from the random data</li>
      </ul>
      
      <div class="info-box">
        <strong>Why Audio Noise?</strong> Audio noise from your microphone contains true randomness that can't be predicted or reproduced, making it ideal for cryptographic applications.
      </div>
    </section>

    <!-- Process Flow -->
    <section class="section">
      <h2>üîÑ Process Flow</h2>
      <div class="process-flow">
        <div class="process-step">
          <h4>1. Audio Capture</h4>
          <p>Microphone captures ambient noise and converts it to digital audio samples</p>
        </div>
        <div class="process-step">
          <h4>2. Bit Extraction</h4>
          <p>Each audio sample is converted to a single bit (0 or 1) using the least significant bit</p>
        </div>
        <div class="process-step">
          <h4>3. Von Neumann Correction</h4>
          <p>Pairs of bits are analyzed to eliminate bias - only 01 and 10 pairs are kept</p>
        </div>
        <div class="process-step">
          <h4>4. Byte Assembly</h4>
          <p>8 corrected bits are combined to form a single byte (0-255)</p>
        </div>
        <div class="process-step">
          <h4>5. Data Collection</h4>
          <p>1000 bytes are collected before processing</p>
        </div>
        <div class="process-step">
          <h4>6. SHA-256 Hashing</h4>
          <p>The collected data is hashed using SHA-256 for additional security</p>
        </div>
        <div class="process-step">
          <h4>7. Password Generation</h4>
          <p>Random bytes are used to select characters for password generation</p>
        </div>
      </div>
    </section>

    <!-- Technical Details -->
    <section class="section">
      <h2>‚öôÔ∏è Technical Details</h2>
      
      <h3>Audio Processing</h3>
      <p>The app uses the Web Audio API to capture real-time audio from your microphone:</p>
      <div class="code-block">
        <code>
// Audio context setup
const audioCtx = new AudioContext();
const analyser = audioCtx.createAnalyser();
analyser.fftSize = 1024;

// Capture audio data
const data = new Uint8Array(analyser.fftSize);
analyser.getByteTimeDomainData(data);
        </code>
      </div>

      <h3>Von Neumann Correction</h3>
      <p>Raw audio data often contains bias (more 1s than 0s or vice versa). Von Neumann correction eliminates this bias:</p>
      
      <div class="diagram">
        <svg width="400" height="200" viewBox="0 0 400 200">
          <!-- Raw bits -->
          <text x="50" y="30" fill="#ff6b6b" font-size="14" font-weight="bold">Raw Audio Bits:</text>
          <text x="50" y="50" fill="#e0e0e0" font-family="monospace" font-size="12">1 0 1 1 0 0 1 1 0 1 0 0 1 1 0 1</text>
          
          <!-- Pairs -->
          <text x="50" y="80" fill="#4ecdc4" font-size="14" font-weight="bold">Bit Pairs:</text>
          <text x="50" y="100" fill="#e0e0e0" font-family="monospace" font-size="12">10 11 00 11 01 00 11 01</text>
          
          <!-- Filtered -->
          <text x="50" y="130" fill="#45b7d1" font-size="14" font-weight="bold">Von Neumann Filtered:</text>
          <text x="50" y="150" fill="#e0e0e0" font-family="monospace" font-size="12">0 1 0 1</text>
          
          <!-- Arrows -->
          <path d="M 200 60 L 250 60" stroke="#4caf50" stroke-width="2" marker-end="url(#arrowhead)"/>
          <path d="M 200 110 L 250 110" stroke="#4caf50" stroke-width="2" marker-end="url(#arrowhead)"/>
          
          <!-- Legend -->
          <text x="280" y="50" fill="#ff6b6b" font-size="10">Raw (biased)</text>
          <text x="280" y="70" fill="#4ecdc4" font-size="10">Paired</text>
          <text x="280" y="90" fill="#45b7d1" font-size="10">Filtered (unbiased)</text>
          
          <defs>
            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
              <polygon points="0 0, 10 3.5, 0 7" fill="#4caf50"/>
            </marker>
          </defs>
        </svg>
      </div>

      <div class="code-block">
        <code>
// Von Neumann correction algorithm
if (b1 === 0 && b2 === 1) finalBitBuffer.push(0);  // Keep 01 ‚Üí 0
else if (b1 === 1 && b2 === 0) finalBitBuffer.push(1);  // Keep 10 ‚Üí 1
// Discard 00 and 11 pairs (biased)
        </code>
      </div>

      <h3>SHA-256 Hashing</h3>
      <p>After collecting 1000 bytes, the data is hashed using SHA-256 to ensure cryptographic security:</p>
      <div class="code-block">
        <code>
// SHA-256 hashing
const asciiString = String.fromCharCode(...collectedNumbers);
const digest = await crypto.subtle.digest("SHA-256", 
  new TextEncoder().encode(asciiString));
        </code>
      </div>

      <div class="success-box">
        <strong>Security Benefit:</strong> Even if an attacker could somehow predict the audio noise, the SHA-256 hash makes it computationally infeasible to reverse-engineer the original data.
      </div>
    </section>

    <!-- Security Analysis -->
    <section class="section">
      <h2>üîí Security Analysis</h2>
      
      <h3>Entropy Sources</h3>
      <table>
        <thead>
          <tr>
            <th>Source</th>
            <th>Entropy Quality</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Microphone Noise</td>
            <td>High</td>
            <td>Ambient environmental noise, electronic noise, thermal noise</td>
          </tr>
          <tr>
            <td>Von Neumann Correction</td>
            <td>Perfect</td>
            <td>Eliminates all bias, ensuring 50/50 distribution</td>
          </tr>
          <tr>
            <td>SHA-256 Hashing</td>
            <td>Cryptographic</td>
            <td>Provides additional security layer and uniform distribution</td>
          </tr>
        </tbody>
      </table>

      <h3>Attack Resistance</h3>
      <ul>
        <li><strong>Predictability:</strong> Audio noise is inherently unpredictable</li>
        <li><strong>Bias Elimination:</strong> Von Neumann correction removes statistical bias</li>
        <li><strong>Cryptographic Security:</strong> SHA-256 provides one-way hashing</li>
        <li><strong>Local Processing:</strong> All data stays on your device</li>
      </ul>

      <div class="warning-box">
        <strong>Important:</strong> This method is suitable for password generation and non-critical applications. For high-security applications, consider using hardware random number generators or certified cryptographic libraries.
      </div>
    </section>

    <!-- Privacy -->
    <section class="section">
      <h2>üõ°Ô∏è Privacy & Data Handling</h2>
      
      <h3>What We Collect</h3>
      <ul>
        <li><strong>Audio Data:</strong> Processed locally, never transmitted</li>
        <li><strong>Random Numbers:</strong> Generated and used locally only</li>
        <li><strong>Passwords:</strong> Generated and displayed locally only</li>
      </ul>

      <h3>What We Don't Collect</h3>
      <ul>
        <li>No audio data is sent to external servers</li>
        <li>No random numbers are transmitted</li>
        <li>No passwords are stored or transmitted</li>
        <li>No personal information is collected</li>
      </ul>

      <div class="info-box">
        <strong>100% Local Processing:</strong> All audio processing, random number generation, and password creation happens entirely on your device. No data leaves your computer.
      </div>
    </section>

    <!-- Performance -->
    <section class="section">
      <h2>‚ö° Performance Characteristics</h2>
      
      <h3>Generation Speed</h3>
      <ul>
        <li><strong>Raw Bits:</strong> ~1000 bits per second (depends on audio level)</li>
        <li><strong>After Von Neumann:</strong> ~250 bits per second (75% reduction due to filtering)</li>
        <li><strong>Final Output:</strong> ~32 bytes per second (after SHA-256 processing)</li>
      </ul>

      <h3>Quality Metrics</h3>
      <ul>
        <li><strong>Bias:</strong> Eliminated by Von Neumann correction</li>
        <li><strong>Distribution:</strong> Uniform across all byte values (0-255)</li>
        <li><strong>Correlation:</strong> No correlation between consecutive outputs</li>
        <li><strong>Periodicity:</strong> No detectable patterns or cycles</li>
      </ul>

      <h3>Optimization Tips</h3>
      <ul>
        <li>Ensure good microphone input levels (30-70% on the level meter)</li>
        <li>Use in a quiet environment for consistent noise</li>
        <li>Allow the system to collect data for better entropy</li>
        <li>Generate longer passwords for better security</li>
      </ul>
    </section>

    <!-- Mathematical Foundation -->
    <section class="section">
      <h2>üìê Mathematical Foundation</h2>
      
      <h3>Von Neumann Correction Theory</h3>
      <p>If raw bits have bias <em>p</em> (probability of 1), then:</p>
      <ul>
        <li>P(01) = p(1-p)</li>
        <li>P(10) = (1-p)p = p(1-p)</li>
        <li>P(00) = (1-p)¬≤</li>
        <li>P(11) = p¬≤</li>
      </ul>
      
      <p>Since P(01) = P(10), the filtered output has perfect 50/50 distribution regardless of input bias.</p>

      <h3>Entropy Calculation</h3>
      <p>For <em>n</em> bits after Von Neumann correction:</p>
      <ul>
        <li>Entropy = n bits (maximum possible)</li>
        <li>Efficiency = 25% (due to discarding 00 and 11 pairs)</li>
        <li>Quality = Perfect (no bias, uniform distribution)</li>
      </ul>

      <div class="code-block">
        <code>
// Entropy calculation example
const rawBits = 1000;           // Input bits
const bias = 0.6;               // 60% ones, 40% zeros
const keptPairs = rawBits * bias * (1 - bias) * 2;  // ~480 bits
const entropy = keptPairs;      // 480 bits of perfect entropy
        </code>
      </div>
    </section>

    <!-- Conclusion -->
    <section class="section">
      <h2>üéØ Conclusion</h2>
      <p>The Audio RNG Password Generator combines multiple layers of security and randomness to create cryptographically secure passwords:</p>
      
      <ol>
        <li><strong>True Randomness:</strong> Audio noise provides unpredictable entropy</li>
        <li><strong>Bias Elimination:</strong> Von Neumann correction ensures perfect distribution</li>
        <li><strong>Cryptographic Security:</strong> SHA-256 hashing adds additional protection</li>
        <li><strong>Privacy Protection:</strong> All processing happens locally on your device</li>
      </ol>

      <div class="success-box">
        <strong>Result:</strong> You get truly random, secure passwords generated entirely on your device with no external dependencies or privacy concerns.
      </div>

      <div style="text-align: center; margin-top: 2rem;">
        <a href="index.html" class="back-button">üöÄ Try the App</a>
      </div>
    </section>
  </div>
</body>
</html>
